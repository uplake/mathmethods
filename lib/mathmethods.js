// Generated by CoffeeScript 1.6.2
(function() {
  var abs, acos, asin, atan, atan2, ceil, cos, defineProperty, exp, floor, fn, i, log, log10, log2, mapClip, max, min, name, pi, pow, round, roundTo, sin, sqrt, tan, _fn, _ref,
    __slice = [].slice;

  defineProperty = Object.defineProperty;

  if (defineProperty == null) {
    defineProperty = function(object, name, descriptor) {
      if (descriptor.get != null) {
        return object.__defineGetter__(name, descriptor.get);
      } else if (descriptor.value != null) {
        return object[name] = descriptor.value;
      }
    };
  }

  abs = Math.abs, acos = Math.acos, asin = Math.asin, atan = Math.atan, ceil = Math.ceil, cos = Math.cos, exp = Math.exp, floor = Math.floor, log = Math.log, round = Math.round, sin = Math.sin, sqrt = Math.sqrt, tan = Math.tan, atan2 = Math.atan2, max = Math.max, min = Math.min, pow = Math.pow;

  log2 = log(2);

  log10 = log(10);

  pi = Math.PI;

  roundTo = function(me, nearest) {
    if (nearest == null) {
      nearest = 1;
    }
    return round(me / nearest) * nearest;
  };

  module.exports = {
    abs: abs,
    acos: acos,
    asin: asin,
    atan: atan,
    ceil: ceil,
    cos: cos,
    exp: exp,
    floor: floor,
    log: log,
    sin: sin,
    sqrt: sqrt,
    tan: tan,
    atan2: atan2,
    max: max,
    min: min,
    pow: pow,
    random: function(me) {
      return me * Math.random();
    },
    log2: function(me) {
      return log(me) / log2;
    },
    log10: function(me) {
      return log(me) / log10;
    },
    degrad: function(me) {
      return me * pi / 180;
    },
    raddeg: function(me) {
      return me * 180 / pi;
    },
    pi: function(me) {
      return me * pi;
    },
    reciprocal: function(me) {
      return 1 / me;
    },
    squared: function(me) {
      return me * me;
    },
    cubed: function(me) {
      return me * me * me;
    },
    sign: function(me) {
      switch (false) {
        case !(me > 0):
          return 1;
        case !(me < 0):
          return -1;
        default:
          return 0;
      }
    },
    fact: function(me) {
      var n, product;

      n = +me;
      if (n < 0) {
        throw new RangeError("" + n + " is not positive");
      }
      if (n !== (n | 0)) {
        throw new TypeError("" + n + " is not an integer");
      }
      product = 1;
      while (n) {
        product *= n--;
      }
      return product;
    },
    roundTo: roundTo,
    round: roundTo,
    hypot: function(me, y) {
      return (me * me + y * y).sqrt;
    },
    div: function(me, denominator) {
      return (me / denominator) | 0;
    },
    clip: function(me, lo, hi) {
      switch (false) {
        case !(me < lo):
          return lo;
        case !(hi < me):
          return hi;
        default:
          return +me;
      }
    },
    exclusivelyBetween: function(me, lo, hi) {
      return (lo < me) && (me < hi);
    },
    inclusivelyBetween: function(me, lo, hi) {
      return (lo <= me) && (me <= hi);
    },
    nextPowerOf: function(me, base) {
      if (base === 1) {
        return 1;
      }
      return pow(base, ceil(log(me) / log(base)));
    },
    previousPowerOf: function(me, base) {
      if (base === 1) {
        return 1;
      }
      return pow(base, ceil(log(me) / log(base)) - 1);
    },
    absdif: function(me, that) {
      return (me - that).abs;
    },
    fuzzyEqual: function(me, that, precision) {
      if (precision == null) {
        precision = 0.001;
      }
      return (1.0 - abs(me - that) / precision).max(0);
    },
    frac: function(me) {
      return me - (me | 0);
    },
    factors: function(me) {
      var i, n_factors;

      n_factors = [];
      i = 1;
      while (i <= Math.floor(Math.sqrt(me))) {
        if (me % i === 0) {
          n_factors.push(i);
          if (me / i !== i) {
            n_factors.push(me / i);
          }
        }
        i++;
      }
      n_factors.sort(function(a, b) {
        return a - b;
      });
      return n_factors;
    },
    linlin: function(me, inMin, inMax, outMin, outMax, clip) {
      var _ref;

      if (clip == null) {
        clip = 'minmax';
      }
      return (_ref = mapClip(me, inMin, inMax, outMin, outMax, clip)) != null ? _ref : (me - inMin) / (inMax - inMin) * (outMax - outMin) + outMin;
    },
    linexp: function(me, inMin, inMax, outMin, outMax, clip) {
      var _ref;

      if (clip == null) {
        clip = 'minmax';
      }
      return (_ref = mapClip(me, inMin, inMax, outMin, outMax, clip)) != null ? _ref : pow(outMax / outMin, (me - inMin) / (inMax - inMin)) * outMin;
    },
    explin: function(me, inMin, inMax, outMin, outMax, clip) {
      var _ref;

      if (clip == null) {
        clip = 'minmax';
      }
      return (_ref = mapClip(me, inMin, inMax, outMin, outMax, clip)) != null ? _ref : log(me / inMin) / log(inMax / inMin) * (outMax - outMin) + outMin;
    },
    expexp: function(me, inMin, inMax, outMin, outMax, clip) {
      var _ref;

      if (clip == null) {
        clip = 'minmax';
      }
      return (_ref = mapClip(me, inMin, inMax, outMin, outMax, clip)) != null ? _ref : pow(outMax / outMin, log(me / inMin) / log(inMax / inMin)) * outMin;
    },
    lincurve: function(me, inMin, inMax, outMin, outMax, curve, clip) {
      var a, b, grow, scaled;

      if (inMin == null) {
        inMin = 0;
      }
      if (inMax == null) {
        inMax = 1;
      }
      if (outMin == null) {
        outMin = 0;
      }
      if (outMax == null) {
        outMax = 1;
      }
      if (curve == null) {
        curve = -4;
      }
      if (clip == null) {
        clip = 'minmax';
      }
      clip = mapClip(me, inMin, inMax, outMin, outMax, clip);
      if (clip != null) {
        return clip;
      }
      if (abs(curve) < 0.001) {
        me.linlin(inMin, inMax, outMin, outMax);
      }
      grow = exp(curve);
      a = (outMax - outMin) / (1 - grow);
      b = outMin + a;
      scaled = (me - inMin) / (inMax - inMin);
      return b - (a * pow(grow, scaled));
    },
    curvelin: function(me, inMin, inMax, outMin, outMax, curve, clip) {
      var a, b, grow, scaled;

      if (inMin == null) {
        inMin = 0;
      }
      if (inMax == null) {
        inMax = 1;
      }
      if (outMin == null) {
        outMin = 0;
      }
      if (outMax == null) {
        outMax = 1;
      }
      if (curve == null) {
        curve = -4;
      }
      if (clip == null) {
        clip = 'minmax';
      }
      clip = mapClip(me, inMin, inMax, outMin, outMax, clip);
      if (clip != null) {
        return clip;
      }
      if (abs(curve) < 0.001) {
        me.linlin(inMin, inMax, outMin, outMax);
      }
      grow = exp(curve);
      a = (outMax - outMin) / (1 - grow);
      b = outMin + a;
      scaled = (me - inMin) / (inMax - inMin);
      return log((b - scaled) / a) / curve;
    }
  };

  mapClip = function(me, inMin, inMax, outMin, outMax, clip) {
    switch (clip) {
      case 'minmax':
        if (me <= inMin) {
          return outMin;
        }
        if (me >= inMax) {
          return outMax;
        }
        break;
      case 'min':
        if (me <= inMin) {
          return outMin;
        }
        break;
      case 'max':
        if (me >= inMax) {
          return outMax;
        }
    }
    return null;
  };

  _ref = module.exports;
  _fn = function(fn) {
    var descriptor;

    descriptor = {
      enumerable: false
    };
    if (fn.length === 1) {
      descriptor.get = function() {
        return fn(this);
      };
    } else {
      descriptor.value = function() {
        var args;

        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return fn.apply(null, [this].concat(args));
      };
    }
    return defineProperty(Number.prototype, name, descriptor);
  };
  for (name in _ref) {
    fn = _ref[name];
    _fn(fn);
  }

  if (require.main === module) {
    console.log((function() {
      var _i, _results;

      _results = [];
      for (i = _i = 0; _i <= 10; i = ++_i) {
        _results.push((i / 10).lincurve());
      }
      return _results;
    })());
    console.log((function() {
      var _i, _results;

      _results = [];
      for (i = _i = 0; _i <= 10; i = ++_i) {
        _results.push((i / 10).lincurve().curvelin());
      }
      return _results;
    })());
  }

}).call(this);
